From 1f7927f916609fa99f472a6fe2e1e4df7c37d965 Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Tue, 27 Jun 2017 02:17:39 +0200
Subject: [PATCH] udev: fix some incorrect usages of CLOCK_BOOTTIME (#6198)

CLOCK_BOOTTIME should only be used if we actually want the clock to
count on while we are suspended, and it is hence not useful for normal
code execution time limits, fix that.

Moreover, a couple of uses were even more broken, as
clock_bottime_or_monotonic() was called where actually
now(clock_boottime_or_monotic()) was supposed to be called. Ouch!

Fixes: #5903
---
 src/udev/udev-event.c | 10 +++++-----
 src/udev/udevd.c      | 12 ++++++------
 2 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/udev/udev-event.c b/src/udev/udev-event.c
index 476122278..894bbbad2 100644
--- a/src/udev/udev-event.c
+++ b/src/udev/udev-event.c
@@ -56,7 +56,7 @@ struct udev_event *udev_event_new(struct udev_device *dev) {
         event->udev = udev;
         udev_list_init(udev, &event->run_list, false);
         udev_list_init(udev, &event->seclabel_list, false);
-        event->birth_usec = clock_boottime_or_monotonic();
+        event->birth_usec = now(CLOCK_MONOTONIC);
         return event;
 }
 
@@ -496,7 +496,7 @@ static void spawn_read(struct udev_event *event,
                 if (timeout_usec > 0) {
                         usec_t age_usec;
 
-                        age_usec = clock_boottime_or_monotonic() - event->birth_usec;
+                        age_usec = now(CLOCK_MONOTONIC) - event->birth_usec;
                         if (age_usec >= timeout_usec) {
                                 log_error("timeout '%s'", cmd);
                                 return;
@@ -647,13 +647,13 @@ static int spawn_wait(struct udev_event *event,
         if (timeout_usec > 0) {
                 usec_t usec, age_usec;
 
-                usec = now(clock_boottime_or_monotonic());
+                usec = now(CLOCK_MONOTONIC);
                 age_usec = usec - event->birth_usec;
                 if (age_usec < timeout_usec) {
                         if (timeout_warn_usec > 0 && timeout_warn_usec < timeout_usec && age_usec < timeout_warn_usec) {
                                 spawn.timeout_warn = timeout_warn_usec - age_usec;
 
-                                r = sd_event_add_time(e, NULL, clock_boottime_or_monotonic(),
+                                r = sd_event_add_time(e, NULL, CLOCK_MONOTONIC,
                                                       usec + spawn.timeout_warn, USEC_PER_SEC,
                                                       on_spawn_timeout_warning, &spawn);
                                 if (r < 0)
@@ -662,7 +662,7 @@ static int spawn_wait(struct udev_event *event,
 
                         spawn.timeout = timeout_usec - age_usec;
 
-                        r = sd_event_add_time(e, NULL, clock_boottime_or_monotonic(),
+                        r = sd_event_add_time(e, NULL, CLOCK_MONOTONIC,
                                               usec + spawn.timeout, USEC_PER_SEC, on_spawn_timeout, &spawn);
                         if (r < 0)
                                 return r;
diff --git a/src/udev/udevd.c b/src/udev/udevd.c
index 28ac44fb8..7ff7d4b88 100644
--- a/src/udev/udevd.c
+++ b/src/udev/udevd.c
@@ -275,12 +275,12 @@ static void worker_attach_event(struct worker *worker, struct event *event) {
 
         e = worker->manager->event;
 
-        assert_se(sd_event_now(e, clock_boottime_or_monotonic(), &usec) >= 0);
+        assert_se(sd_event_now(e, CLOCK_MONOTONIC, &usec) >= 0);
 
-        (void) sd_event_add_time(e, &event->timeout_warning, clock_boottime_or_monotonic(),
+        (void) sd_event_add_time(e, &event->timeout_warning, CLOCK_MONOTONIC,
                                  usec + arg_event_timeout_warn_usec, USEC_PER_SEC, on_event_timeout_warning, event);
 
-        (void) sd_event_add_time(e, &event->timeout, clock_boottime_or_monotonic(),
+        (void) sd_event_add_time(e, &event->timeout, CLOCK_MONOTONIC,
                                  usec + arg_event_timeout_usec, USEC_PER_SEC, on_event_timeout, event);
 }
 
@@ -746,9 +746,9 @@ static void manager_exit(Manager *manager) {
         event_queue_cleanup(manager, EVENT_QUEUED);
         manager_kill_workers(manager);
 
-        assert_se(sd_event_now(manager->event, clock_boottime_or_monotonic(), &usec) >= 0);
+        assert_se(sd_event_now(manager->event, CLOCK_MONOTONIC, &usec) >= 0);
 
-        r = sd_event_add_time(manager->event, NULL, clock_boottime_or_monotonic(),
+        r = sd_event_add_time(manager->event, NULL, CLOCK_MONOTONIC,
                               usec + 30 * USEC_PER_SEC, USEC_PER_SEC, on_exit_timeout, manager);
         if (r < 0)
                 return;
@@ -782,7 +782,7 @@ static void event_queue_start(Manager *manager) {
             manager->exit || manager->stop_exec_queue)
                 return;
 
-        assert_se(sd_event_now(manager->event, clock_boottime_or_monotonic(), &usec) >= 0);
+        assert_se(sd_event_now(manager->event, CLOCK_MONOTONIC, &usec) >= 0);
         /* check for changed config, every 3 seconds at most */
         if (manager->last_usec == 0 ||
             (usec - manager->last_usec) > 3 * USEC_PER_SEC) {
-- 
2.21.0

